链接：https://www.nowcoder.com/questionTerminal/81f67946105b4509a5257fc2077db67d
来源：牛客网

jdk1.7 中使用个 Entry 数组来存储数据，用key的 hashcode 取模来决定key会被放到数组里的位置，如果 hashcode 相同，或者 hashcode 取模后的结果相同（ hash collision ），那么这些 key 会被定位到 Entry 数组的同一个格子里，这些 key 会形成一个链表。在 hashcode 特别差的情况下，比方说所有key的 hashcode 都相同，这个链表可能会很长，那么 put/get 操作都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到 O(n)

jdk1.8 中使用一个 Node 数组来存储数据，但这个 Node 可能是链表结构，也可能是红黑树结构，如果插入的 key 的 hashcode 相同，那么这些key也会被定位到 Node 数组的同个格子里。如果同一个格子里的key不超过8个，使用链表结构存储。如果超过了8个，那么会调用 treeifyBin 函数，将链表转换为红黑树。那么即使 hashcode 完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销也就是说put/get的操作的时间复杂度最差只有 O(log n)，但是真正想要利用 JDK1.8 的好处，有一个限制：key的对象，必须正确的实现了 Compare 接口




常见的内部排序有： 插入排序（直接插入排序）：将待排序的数字逐渐插入到已排好序的元素序列中，需要关键字的比较。 快速排序：通过一趟排序将待排序数列分割为两部分，一部分比基准值大，另一部分比基准值小，需要关键字的比较。 选择排序(简单选择排序)：从待排序序列中选择一个最大（或最小）的元素放在序列的首位置，直到所有的序列排列完成。需要关键字比较。 归并排序：将序列先拆分为多个子序列，使子序列有序，再逐步合并，直至整个序列有序。需要关键字比较。 冒泡排序：相邻元素逐个比较做交换。 希尔排序：缩小增量排序，属于插入排序的一种。 堆排序：大根堆的要求是每个节点的值都不大于其父节点的值，小根堆相反。


